<!DOCTYPE html >
< html >
< tête >
  < titre > Jeu HTML de base de Pong </ titre >
  < meta  charset =" UTF-8 " >
  < style >
  html ,  corps {
    hauteur :  100 % ;
    marge :  0 ;
  }

  corps {
    fond : noir;
    affichage : flex;
    align-items : centre ;
    justifier-contenu : centre ;
  }
  </ style >
</ tête >
< corps >
< largeur du canevas  =" 750 " hauteur =" 585 " id =" jeu " > </ canevas >
< script >
const  canvas  =  document . getElementById ( 'jeu' ) ;
 contexte  const =  canvas . getContext ( '2d' ) ;
 grille  constante =  15 ;
const  paddleHeight  =  grille  *  5 ;  // 80
const  maxPaddleY  =  canvas . height  -  grid  -  paddleHeight ;

var  paddleSpeed  ​​=  6 ;
var  ballSpeed  ​​=  5 ;

const  leftPaddle  =  {
  // commencer au milieu du jeu sur le côté gauche
  x : grille  *  2 ,
  y : toile . hauteur  /  2  -  paddleHauteur  /  2 ,
  largeur : grille ,
  hauteur : pagaieHauteur ,

  // vitesse de la pagaie
  dy : 0
} ;
const  rightPaddle  =  {
  // commencer au milieu du jeu sur le côté droit
  x : toile . largeur  -  grille  *  3 ,
  y : toile . hauteur  /  2  -  paddleHauteur  /  2 ,
  largeur : grille ,
  hauteur : pagaieHauteur ,

  // vitesse de la pagaie
  dy : 0
} ;
const  balle  =  {
  // commencer au milieu du jeu
  x : toile . largeur  /  2 ,
  y : toile . hauteur  /  2 ,
  largeur : grille ,
  hauteur : grille ,

  // garder une trace du moment où il est nécessaire de réinitialiser la position de la balle
  réinitialisation : faux ,

  // vitesse de la balle (commencez à aller dans le coin supérieur droit)
  dx : vitesse de la balle ,
  dy : - vitesse de balle
} ;

// vérifier la collision entre deux objets à l'aide d'une boîte englobante alignée sur l'axe (AABB)
// @voir https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection
fonction  entre en collision ( obj1 ,  obj2 )  {
  renvoie  obj1 . x  <  obj2 . x  +  obj2 . width  &&
         obj1 . x  +  obj1 . largeur  >  obj2 . x  &&
         obj1 . y  <  obj2 . y  +  obj2 . hauteur  &&
         obj1 . y  +  obj1 . hauteur  >  obj2 . y ;
}

// boucle de jeu
 boucle de fonction ( )  {
  requestAnimationFrame ( boucle ) ;
  contexte . clearRect ( 0 , 0 , canvas . width , canvas . height ) ;

  // déplacer les palettes en fonction de leur vitesse
  leftPaddle . y  +=  leftPaddle . dy ;
  rightPaddle . y  +=  rightPaddle . dy ;

  // empêcher les pagaies de traverser les murs
  si  ( leftPaddle . y  <  grille )  {
    leftPaddle . y  =  grille ;
  }
  sinon  si  ( leftPaddle . y  >  maxPaddleY )  {
    gauchePaddle . y  =  maxPaddleY ;
  }

  si  ( rightPaddle . y  <  grille )  {
    rightPaddle . y  =  grille ;
  }
  sinon  si  ( rightPaddle . y  >  maxPaddleY )  {
    droitePaddle . y  =  maxPaddleY ;
  }

  // dessiner des pagaies
  contexte . fillStyle  =  'blanc' ;
  contexte . fillRect ( leftPaddle . x ,  leftPaddle . y ,  leftPaddle . width ,  leftPaddle . height ) ;
  contexte . fillRect ( rightPaddle . x ,  rightPaddle . y ,  rightPaddle . width ,  rightPaddle . height ) ;

  // déplacer la balle par sa vitesse
  balle . x  +=  balle . dx ;
  balle . y  +=  balle . dy ;

  // empêcher la balle de traverser les murs en modifiant sa vitesse
  si  ( balle . y  <  grille )  {
    boule . y  =  grille ;
    balle . dy  *=  - 1 ;
  }
  sinon  si  ( ball.y + grille > canvas.height - grille ) {​​​​       
    boule . y  =  toile . hauteur  -  grille  *  2 ;
    balle . dy  *=  - 1 ;
  }

  // réinitialiser la balle si elle dépasse la raquette (mais seulement si nous ne l'avons pas déjà fait)
  si  (  ( balle . x  <  0  ||  balle . x  >  toile . largeur )  &&  ! balle . réinitialisation )  {
    balle . réinitialisation  =  vrai ;

    // laissez un peu de temps au joueur pour récupérer avant de relancer la balle
    setTimeout ( ( )  =>  {
      balle . réinitialisation  =  faux ;
      balle . x  =  toile . largeur  /  2 ;
      boule . y  =  toile . hauteur  /  2 ;
    } ,  400 ) ;
  }

  // vérifiez si la balle entre en collision avec la raquette. s'ils le font, changez la vitesse x
  si  ( entre en collision ( balle ,  pagaie gauche ) )  {
    balle . dx  *=  - 1 ;

    // déplacez la balle à côté de la raquette sinon la collision se reproduira
    // dans l'image suivante
    balle . x  =  leftPaddle . x  +  leftPaddle . largeur ;
  }
  sinon  si  ( entre en collision ( balle ,  pagaie droite ) )  {
    balle . dx  *=  - 1 ;

    // déplacez la balle à côté de la raquette sinon la collision se reproduira
    // dans l'image suivante
    balle . x  =  rightPaddle . x  -  balle . largeur ;
  }

  // tirer la balle
  contexte . fillRect ( balle . x ,  balle . y ,  balle . largeur ,  balle . hauteur ) ;

  // dessiner des murs
  contexte . fillStyle  =  'lightgrey' ;
  contexte . fillRect ( 0 ,  0 ,  canvas . width ,  grid ) ;
  contexte . fillRect ( 0 ,  canvas . height  -  grille ,  canvas . width ,  canvas . height ) ;

  // tracez une ligne pointillée au milieu
  pour  ( soit  i  =  grille ;  i  <  toile . hauteur  -  grille ;  i  +=  grille  *  2 )  {
    contexte . fillRect ( canvas . width  /  2  -  grille  /  2 ,  i ,  grille ,  grille ) ;
  }
}

// écouter les événements du clavier pour déplacer les palettes
document . addEventListener ( 'keydown' ,  function ( e )  {

  // touche flèche vers le haut
  si  ( e . lequel  ===  38 )  {
    rightPaddle . dy  =  - vitesse de la pagaie ;
  }
  // touche flèche vers le bas
  sinon  si  ( e . lequel  ===  40 )  {
    pagaie droite . dy  =  vitesse de la pagaie ;
  }

  // touche w
  si  ( e . lequel  ===  87 )  {
    pagaie gauche . dy  =  - vitesse de la pagaie ;
  }
  // une clé
  sinon  si  ( e . lequel  ===  83 )  {
    pagaie gauche . dy  =  vitesse de la pagaie ;
  }
} ) ;

// écouter les événements du clavier pour arrêter la raquette si la touche est relâchée
document . addEventListener ( 'keyup' ,  function ( e )  {
  si  ( e . lequel  ===  38  ||  e . lequel  ===  40 )  {
    droitePaddle . dy  =  0 ;
  }

  si  ( e . lequel  ===  83  ||  e . lequel  ===  87 )  {
    pagaie gauche . dy  =  0 ;
  }
} ) ;

// démarrer le jeu
requestAnimationFrame ( boucle ) ;
</ script >
</ corps >
</ html >


